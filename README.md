# LL-1-syntactic-analyzer
LL(1)语法分析器
设计实现：
1.	抽象出一个实体类（Grammar），类中数据成员及成员函数见下图
 
2. 由用户输入终结符号、非终结符号、文法条数，终结符号、非终结符号分别存入vn、vt，并将所有符号以键值对形式存入mv，这样就有了符号和序号的对应，序号用做后面构成First、Follow和预测分析表的索引，文法以‘|’划分成各个产生式存入vg。
3. 先求各个终结符的First集，即是其本身，目的是避免了后面求非终结符号的First集时对产生式右部第一个符号分情况讨论。再求各个非终结符的First集，遍历所有的产生式，用递归的方法求出每一个产生式右部的符号能推出的所有非空终结符号集合，再对能推出ε的非终结符号的First集加ε（以‘$’表示），最后将所有First集中的元素去重。
4. 求每个非终结符的Follow集，先对开始符号加‘#’。遍历所有产生式的右部，对所有非终结符号的右部是终结符号的，直接将终结符号加入其Follow集；再求所有在产生式末尾的非终结符的Follow集，将产生式左边的Follow集加入其Follow集，由于在求First集时已抽象出一个函数（get_f()），所以可以递归地求出能推出的所有非空终结符号集合，这样就避免了一些非终结符能推出ε而漏的情况，最后将Follow集中所有元素去重。
5. 判断文法是否是LL（1）文法，即判断First集中含有ε的非终结符的Follow集与其First集交集是否为空。
6. 构造预测分析表，先找出能推出空的产生式，将这些产生式左边的非终结符与其Follow集中的元素的位置填入产生式。其它的不能直接推出ε就找到其First集，遍历First集，若元素是ε，则说明它可以间接推出ε，那么就找该非终结符的Follow集，将该非终结符与其 Follow集中的元素的位置填入产生式；若非ε，则将产生式填入对应位置。最后按格式输出预测分析表。
LL（1）预测分析表构造算法：
假定初始时分析表为空。
i：= n；            {n是最大产生式编号，即产生式数}
REPEAT
   FOR  i： A→α DO
     IF (α !=  )
     FOR 每个a∈FIRST(α) DO
        把A→α填入M[A，a]中       {填α即可}
     ELSE
     FOR 每个a∈FOLLOW(A) DO
        把A→ 填入M[A，a]中       {填即可}
	 ENDIF
     i：=i-1
UNTIL  i=0  

7. 用户输入待分析句子。构造分析栈（stack），放入‘#’和开始符号。若栈顶元素是非终结符，则找到预测分析表中该非终结符和预留符号串的第一个字符的对应位置，若没有产生式，则不是该文法的句子，若有，则将产生式右部逆序进栈。若栈顶元素是终结符，则与预留符号串的第一个字符匹配，匹配成功出栈，否则不是该文法的句子，知道预留字符串只剩下‘#’，则匹配成功。
预测分析程序算法：
BEGIN 
   INITIAL： PUSH‘#’；
             PUSH 文法开始符 S；
             读入第一个字符送a；

   REPEAT    POP  X；           {弹栈，送入X}
            IF  X∈VT  THEN
               IF X=a  THEN 读入下一个字符送a  ELSE  ERROR
            IF  X∈VN  THEN
               CASE M[X，a] OF
                 ‘X→X1X2…Xn’：PUSH XnXn-1…X1；
                 ‘X→ε’：      SKIP；     {空操作}
                 ‘空白或错误码’：ERROR
               ENDCASE
  UNTIL X=‘#’
  IF X=a=‘#’ THEN 正确接收输入串并停止  
ELSE  ERROR
END；
注：未实现消除左递归
